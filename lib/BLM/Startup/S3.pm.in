package BLM::Startup::S3;

#
#    This file is a part of Bedrock, a server-side web scripting tool.
#    Copyright (C) 2001, Charles Jones, LLC.
#    Copyright (C) 2024, TBC Development Group, LLC.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#
# Application Plugin for interacting with AWS S3

use warnings;
use strict;

use Amazon::S3;
use Amazon::Credentials;
use Bedrock qw(:booleans choose grab_bag);
use Bedrock::Constants qw(:booleans :chars);
use Bedrock::Hash;
use Carp;
use Data::Dumper;
use English qw(-no_match_vars);
use File::Basename qw(basename fileparse);
use List::Util qw(mesh any);
use Scalar::Util qw(reftype);
use Time::Piece;

our $VERSION = '@PACKAGE_VERSION@';

use parent qw(Bedrock::Application::Plugin Class::Accessor::Fast);

__PACKAGE__->follow_best_practice;

__PACKAGE__->mk_accessors(
  qw(
    bucket
    bucket_name
    s3
    region
  )
);

########################################################################
sub init_plugin {
########################################################################
  my ($self) = @_;

  $self->SUPER::init_plugin();

  my $config = $self->config;

  my $aws_access_key_id = $config->{aws_access_key_id} // $ENV{AWS_ACCESS_KEY_ID};

  my $aws_secret_access_key = $config->{aws_secret_access_key} // $ENV{AWS_SECRET_ACCESS_KEY};

  my $token = $ENV{AWS_SESSION_TOKEN};

  my $credentials = Amazon::Credentials->new(
    aws_access_key_id     => $aws_access_key_id,
    aws_secret_access_key => $aws_secret_access_key,
    token                 => $token,
    no_passkey_warning    => $TRUE,
  );

  my $bucket_name = $ENV{AWS_BUCKET}  // $config->{bucket};
  my $region      = $config->{region} // 'us-east-1';
  $self->set_region($region);

  my $s3 = Amazon::S3->new(
    credentials      => $credentials,
    region           => $region,
    host             => $config->{host},
    dns_bucket_names => to_boolean( $config->{dns_bucket_names} ),
    secure           => to_boolean( $config->{secure} ),
  );

  $self->set_s3($s3);

  if ($bucket_name) {
    $self->set_bucket_name($bucket_name);
    $self->bucket;
  }
  else {
    warn "no bucket\n"
      if !$bucket_name;
  }

  return $TRUE;
}

#######################################################################
sub create_session_file {
#######################################################################
  my ( $self, $filename, $content ) = @_;

  my $session_file = eval {
    my $session = $self->session->{session};
    return sprintf '%s/%s', $session, $filename;
  };

  die "unable to create session file name\n$EVAL_ERROR"
    if !$session_file || $EVAL_ERROR;

  $self->add_key( $session_file, $content );

  # suitable for <null $header.location($s3.create_session_file($name, $content))>
  return "/session/$filename";
}

#######################################################################
sub buckets {
#######################################################################
  my ( $self, $verify_region ) = @_;

  my $s3 = $self->get_s3;

  my $bucket_list = eval { return $s3->buckets($verify_region); };

  if ( !$bucket_list || $EVAL_ERROR ) {
    my $errstr = $s3->errstr || $EVAL_ERROR;
    die "could not get bucket list\n$errstr";
  }

  return Bedrock::Array->new( grab_bag( $bucket_list->{buckets} // [], qw(creation_date bucket region) ) );
}

#######################################################################
sub copy_object {
#######################################################################
  my ( $self, $source, $dest, @headers ) = @_;

  my $bucket = $self->get_bucket;

  die "set bucket first\n"
    if !$bucket;

  return $bucket->copy_object(
    key    => $dest,
    source => $source,
    @headers ? ( headers => {@headers} ) : ()
  );
}

#######################################################################
sub add_bucket {
#######################################################################
  my ( $self, $bucket_name ) = @_;

  my $s3 = $self->get_s3;

  my $retval
    = eval { $s3->add_bucket( { bucket => $bucket_name, location_constraint => $self->get_region } ); };

  if ( !$retval || $EVAL_ERROR ) {
    my $errstr = $s3->errstr || $EVAL_ERROR;
    die "could not add $bucket_name\n$errstr";
  }

  return $retval;
}

#######################################################################
sub check_bucket {
#######################################################################
  my ( $self, @args ) = @_;

  my ( $bucket, %options ) = choose {
    return $args[0]
      if @args == 1;

    return $self->get_bucket
      if !@args;

    my %options = @args;
    my $bucket  = delete $options{bucket};
    $bucket //= $self->get_bucket;

    return ( $bucket, %options );
  };

  die "bucket must be a bucket object, not a bucket-name\n"
    if !ref $bucket || ref($bucket) !~ /Amazon::S3::Bucket/xsm;

  return ( $bucket, %options );
}

#######################################################################
sub to_metadata {
#######################################################################
  my ( $self, %options ) = @_;

  foreach my $o ( keys %options ) {
    next if any { $o eq $_ } qw(headers acl_short);
    next if $o =~ /x\-amz\-meta/xsm;

    my $value = delete %options{$o};
    $o = sprintf 'x-amz-meta-%s', lc $o;
    $options{$o} = $value;
  }

  return %options ? \%options : ();
}

#######################################################################
sub add_key {
#######################################################################
  my ( $self, $key, $value, @args ) = @_;

  my ( $bucket, %options ) = $self->check_bucket(@args);

  my $retval = $bucket->add_key( $key, $value, $self->to_metadata(%options) );

  die $self->get_s3->errstr
    if !$retval;

  return $retval;
}

#######################################################################
sub add_key_filename {
#######################################################################
  my ( $self, $key, $filename, @args ) = @_;

  my ( $bucket, %options ) = $self->check_bucket(@args);

  my $retval = $bucket->add_key_filename( $key, $filename, $self->to_metadata(%options) );

  die $self->get_s3->errstr
    if !$retval;

  return $retval;
}

#######################################################################
sub delete_keys {
#######################################################################
  my ( $self, $key, @args ) = @_;

  my ($bucket) = $self->check_bucket(@args);

  my $keylist = ref $key ? $key : [$key];

  $bucket //= $self->get_bucket;

  return $bucket->delete_keys( @{$keylist} );
}

#######################################################################
sub get_key_value {
#######################################################################
  my ( $self, @args ) = @_;

  return $self->get_key(@args)->{value};
}

#######################################################################
sub get_key {
#######################################################################
  my ( $self, $key, @args ) = @_;

  my ($bucket) = $self->check_bucket(@args);

  $bucket //= $self->get_bucket;

  my $obj = $bucket->get_key($key);

  my %metadata;

  foreach ( keys %{$obj} ) {
    next if !/^x[-]amz[-]meta[-](.*)$/xsm;

    my $name           = $1;
    my $canonical_name = $name;
    $canonical_name =~ s/[-]/_/xsmg;

    my $value = delete $obj->{$_};

    $metadata{$name}           = $value;
    $metadata{$canonical_name} = $value;
  }

  $obj->{MetaData} = Bedrock::Hash->new(%metadata);

  return $obj;
}

#######################################################################
sub list_bucket_keys {
#######################################################################
  my ( $self, %args ) = @_;

  my $bucket = delete $args{bucket};
  $bucket //= $self->get_bucket;

  my $result = $self->list_bucket($bucket);

  return $result
    if $args{raw};

  return Bedrock::Array->new( map { $_->{key} } @{ $result->{keys} } );
}

#######################################################################
sub list_bucket {
#######################################################################
  my ( $self, @args ) = @_;

  my ( $bucket, %options ) = @args;

  my $max_keys = delete $options{max_keys};

  if ($max_keys) {
    $options{'max-keys'} = $max_keys;
  }

  $bucket //= $self->get_bucket;

  my $result = eval {

    return $bucket->list_v2( \%options )
      if $options{'max-keys'};

    return $bucket->list_all_v2( \%options );
  };

  # roll up common prefixes as keys
  if ( $options{delimiter} && $result->{common_prefixes} ) {
    foreach my $k ( @{ $result->{common_prefixes} } ) {
      my $key = {
        key               => $k . $options{delimiter},
        owner_displayname => $EMPTY,
        storage_class     => $EMPTY,
        last_modified     => $EMPTY,
        size              => $EMPTY,
        etag              => $EMPTY,
      };

      push @{$result}, $key;
    }
  }

  return $result;
}

#######################################################################
sub parse_key {
#######################################################################
  my ( $self, $key ) = @_;

  my ( $name, $path, $ext ) = fileparse( $key, qr/[.][^.]+$/xsm );

  return Bedrock::Hash->new(
    name     => $name,
    path     => $path,
    ext      => $ext,
    filename => "$name$ext",
  );
}

#######################################################################
sub bucket {
########################################################################
  my ( $self, $bucket_name ) = @_;

  my $bucket = $self->get_bucket;

  return $bucket
    if $bucket;

  $bucket_name //= $self->get_bucket_name;

  $bucket = $self->get_s3->bucket($bucket_name);
  $self->set_bucket($bucket);

  return $bucket;
}

1;

__END__

=pod

=head1 PUBLIC

BLM::Startup::S3 - Bedrock Application Plugin for AWS S3

=head1 SYNOPSIS

Create a F<s3.xml> configuration file and drop it in the usual places
Bedrock looks for config files.

 <object> 
   <scalar name="binding">s3</scalar> 
   <scalar name="module">BLM::Startup::S3</scalar> 
     <object name="config">
       <scalar name="bucket">treasurersbriefcase-development</scalar>
     </object>
 </object>

A LocalStack configuration...

 <object>
   <scalar name="binding">s3</scalar>
   <scalar name="module">BLM::Startup::S3</scalar>
   <object name="config">
     <scalar name="aws_access_key_id">test</scalar>
     <scalar name="aws_secret_access_key">test</scalar>
     <scalar name="region">us-east-1</scalar>
     <scalar name="host">localhost:4566</scalar>
     <scalar name="secure">false</scalar>
     <scalar name="dns_bucket_names">0</scalar>
   </object>
 </object>

Usage in Bedrock:

 <null:list $s3.list_bucket('delimiter', '/') >

=head1 DESCRIPTION

Provides a convenient, Bedrock-optimized interface to L<Amazon::S3>. 
These routines return Bedrock objects (hashes/arrays) instead of raw Perl 
structures, making them easier to use in templates.

You can still access the raw L<Amazon::S3> object if you need deep magic:

 <null:s3_client $s3.get_s3()>
 <null:result $s3_client.list_bucket()>

=head1 CONFIGURATION

See L<Amazon::S3> for details on credential handling. Bedrock supports standard
AWS environment variables or explicit config keys.

=head1 METHODS

=head2 add_bucket

 add_bucket(bucket-name)

Creates a new bucket in the region specified by your configuration.

 my $s3 = $self->get_s3;
 $s3->add_bucket({ bucket => $bucket_name, ...});
 $self->bucket($bucket_name);

I<NOTE: This does not set the new bucket as the current active bucket. Use C<bucket()> to switch contexts.>

=head2 add_key

 add_key(key, value, [ bucket ], metadata-key, metadata-value, ... )

Adds a new object to a bucket. 

Arguments:
* C<key>: The path/filename in S3.
* C<value>: The content string (file body).
* C<bucket>: (Optional) An Amazon::S3::Bucket object.
* C<metadata>: Any remaining arguments are treated as metadata key/value pairs.

Example:

 <null:readme $s3.get_key('README.md')>
 <null:html --markdown $readme.value>
 <null $s3.add_key('README.html', $html, 'content-type', 'text/html')>

=head2 add_key_filename

 add_key_filename(key, filename, [ bucket ], metadata-key, metadata-value )

Same as L</add_key>, but the C<value> argument is a local filesystem path.
The file will be read and uploaded to S3.

Example (Bedrock Shell):
 echo '<null $s3.add_key_filename("README.md", "/tmp/README.md")>' | \
    bedrock --config-var ABSOLUTE_PATHS=yes

=head2 bucket

 bucket(bucket-name)

Switch the active bucket for subsequent calls. If no name is provided, returns
the current bucket object.

=head2 buckets

 buckets( [verify_region] )

Returns a Bedrock Array of bucket metadata hashes.

 <foreach $s3.buckets>
    Bucket: <var $_.bucket> (<var $_.region>)
 </foreach>

Fields returned:
* C<bucket>
* C<creation_date>
* C<region>

=head2 copy_object

 copy_object(source_key, dest_key, [headers])

Copies an object within the bucket. C<headers> is an optional list of key/value pairs.

Example:
 <null $s3.copy_object('/resources/info.pdf', '/archive/info-2024.pdf')>

=head2 create_session_file

 create_session_file(filename, content)

Helper method to save content to the current session's "directory" in S3.
Assuming your session storage is S3-backed, this creates a file at:
C<session_id/filename>.

Returns the relative web path: C</session/filename>.

=head2 delete_keys

 delete_keys(key | [keys], [bucket])

Deletes one or more keys. Accepts a single string key or an array reference of keys.

Example:
 <null:keylist $s3.list_bucket('delimiter', '/', 'prefix', $session.session)>
 <null $s3.delete_keys($keylist.keys)>

=head2 get_key

 get_key(key, [ bucket ])

Retrieves an object. Returns a hash containing the body and metadata.

Returns:
* C<value>: The object content (body).
* C<etag>: The ETag of the object.
* C<content_length>: Size in bytes.
* C<content_type>: MIME type.
* C<MetaData>: A hash of metadata (x-amz-meta-* stripped).

=head2 get_key_value

 get_key_value(key, [ bucket ])

Convenience shortcut. Returns I<only> the body content (the C<value> field) of the object.

 <var --markdown $s3.get_key_value('README.md')>

=head2 list_bucket

 list_bucket(args)

List objects in the bucket. Arguments are passed as key/value pairs.
See L<Amazon::S3> for valid arguments (prefix, delimiter, max-keys, etc).

Example:
 <null:list $s3.list_bucket('delimiter', '/', 'prefix', 'images/', 'max-keys', 100)>

Returns a hash:
* C<keys>: Array of object metadata (key, etag, size, last_modified).
* C<common_prefixes>: Array of "folders" (if delimiter is used).
* C<is_truncated>: Boolean.
* C<next_marker>: Pagination token.

=head2 list_bucket_keys

 list_bucket_keys( [ bucket => bucket , raw => 1] )

Convenience wrapper around C<list_bucket>. Returns a simple Bedrock Array of 
key strings, discarding the metadata.

 <foreach $s3.list_bucket_keys()>
   Found file: <var $_>
 </foreach>

=head2 parse_key

 parse_key(key)

Utility to parse an S3 key into filename components (similar to L<File::Basename>).

 <null:parts $s3.parse_key('foo/bar/baz.jpg')>
 
 Returns:
 * name:     baz
 * path:     foo/bar/
 * ext:      .jpg
 * filename: baz.jpg

=head2 set_bucket_name

 set_bucket_name(bucket-name)

Sets the default bucket name for the plugin instance.

=head1 METADATA

Amazon S3 expects metadata headers to be prefixed with C<x-amz-meta->.
This plugin handles that automatically. You can pass simple names (e.g., C<account-id>)
and they will be converted.

B<Writing:>
 <null $s3.add_key('report.pdf', $content, 'account-id', 123)>

B<Reading:>
 <null:obj $s3.get_key('report.pdf')>
 Account ID: <var $obj.MetaData.account_id>

I<Note that dashes ('-') in metadata names are converted to underscores ('_').>

=head1 SEE ALSO

L<Amazon::S3>, L<Bedrock::Application::Plugin>

=head1 AUTHOR

Rob Lauer - <rlauer@treasurersbriefcase.com>

=cut
