package Bedrock::Apache::BedrockS3Handler;

#    Copyright (C) 2025, TBC Development Group, LLC
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

use strict;
use warnings;

use Bedrock qw(choose to_boolean);
use Bedrock::Apache::Constants qw($OK);
use Bedrock::Constants qw(%DEFAULT_MIME_TYPES :booleans);
use Bedrock::S3;
use Carp;
use English qw(-no_match_vars);
use File::Basename qw(fileparse);
use Role::Tiny;

use Readonly;
Readonly::Scalar our $BUFFER_SIZE     => 4 * 1024;
Readonly::Scalar our $EMPTY           => q{};
Readonly::Scalar our $DEFAULT_S3_HOST => 'https://s3.amazonaws.com';

our $VERSION = '@PACKAGAGE_VERSION@';

{

  my $s3_config;

########################################################################
  sub get_s3_config {
########################################################################
    my ($config) = @_;

    $config //= {};

    return $s3_config
      if $s3_config;

    my $host   = $ENV{S3_HOST} // $config->{host} // 's3.amazonaws.com';
    my $secure = to_boolean( $config->{secure} );
    $secure = defined $secure ? $secure : $host eq 's3.amazonaws.com' ? 1 : 0;

    my $dns_bucket_names      = $config->{dns_bucket_names} // $ENV{S3_HOST} ? $FALSE : $TRUE;
    my $bucket                = $config->{bucket}           // $ENV{AWS_BUCKET};
    my $aws_access_key_id     = $ENV{AWS_ACCESS_KEY_ID}     // $config->{aws_access_key_id};
    my $aws_secret_access_key = $ENV{AWS_SECRET_ACCESS_KEY} // $config->{aws_secret_access_key};
    my $token                 = $ENV{AWS_SESSION_TOKEN};

    $s3_config->{session_prefix} //= $EMPTY;

    $s3_config = Bedrock::S3->new(
      { bucket_name           => $bucket,
        aws_access_key_id     => $aws_access_key_id,
        aws_secret_access_key => $aws_secret_access_key,
        token                 => $token,
        host                  => $host,
        secure                => $secure ? $TRUE : $FALSE,
        dns_bucket_names      => $dns_bucket_names,
      }
    );

    return $s3_config;
  }
}

########################################################################
sub get_key_from_filename {
########################################################################
  my ( $filename, $session_dir ) = @_;

  my $key = choose {
    my $key = $filename;

    if ( !$session_dir ) {
      $key =~ s/^.*session\///xsm;
      return $key;
    }

    $key =~ s/^$session_dir\///xsm;
    return $key;
  };

  my $prefix = get_s3_config->{session_prefix};

  if ( $prefix && $prefix !~ /\/$/xsm ) {
    $prefix = "$prefix/";
  }

  return sprintf '%s%s', $prefix, $key;
}

########################################################################
sub get_s3_session_file {
########################################################################
  my ( $filename, $session_dir ) = @_;

  my $key = get_key_from_filename( $filename, $session_dir );

  my $bucket = get_s3_config->get_bucket;

  my $obj = eval { $bucket->get_key($key); };

  if ( !$obj || $EVAL_ERROR ) {
    carp sprintf 'unable to fetch [%s] from S3: [%s]', $key, $EVAL_ERROR // $EMPTY;
    carp sprintf 'errstr: [%s]', $bucket->errstr // $EMPTY;
  }

  return $obj;
}

########################################################################
sub send_s3_file {
########################################################################
  my ( $r, $filename, $session_dir ) = @_;

  my $obj = get_s3_session_file( $filename, $session_dir );

  die 'not found'
    if !$obj;

  my ( $name, $path, $ext ) = fileparse( $filename, qr/[.][^.]+$/xsm );

  my $value = $obj->{value};

  my $mime_type = eval {
    require File::MimeInfo::Magic;
    File::MimeInfo::Magic->import('mimetype');

    open my $fh, '<', \$value;
    my $mime_type = File::MimeInfo::Magic($fh);
    close $fh;

    return $mime_type;
  };

  $mime_type = eval {
    require File::Type;
    return File::Type->new->mime_type($value);
  };

  if ( !$mime_type || $mime_type =~ /octet\-stream/xsm ) {
    # see if we can do better than octet/
    $mime_type = $DEFAULT_MIME_TYPES{$ext};

    if ( !$mime_type ) {
      $r->log->warn( 'could not determine mime-type ' . $EVAL_ERROR );
      $mime_type = 'application/octet-stream';
    }
  }

  $r->content_type($mime_type);

  $r->send_http_header;

  $r->print( $obj->{value} );

  return $TRUE;
}

########################################################################
sub send_file {
########################################################################
  my ( $r, $filename ) = @_;

  my $buffer;

  my $mime_type = File::Type->new->mime_type($filename);
  $r->content_type($mime_type);

  $r->send_http_header;

  open my $fh, '<', $filename
    or die 'server error';

  while ( read $fh, $buffer, $BUFFER_SIZE ) {
    $r->print($buffer);
  }

  close $fh;

  return $TRUE;
}

1;

__END__

=pod

=head1 NAME

Apache::Bedrock:S3Handler - Role for use with Apache::BedrockCloudSessionFiles

=head1 DESCRIPTION

Role that provides useful methods for implementing S3 based
applications.

=head1 METHODS AND SUBROUTINES

=head2 get_s3_config 

Returns a class that class that implements getters for the S3 client
and bucket objects.

=head3 Use Environment Variables or a Configuration Object

When this class is loaded, the configuration object is initialized
from the environment or from Bedrock's global configuration object.

You can add an C<s3> object to Bedrock's global configuration file by
either adding it directly to your C<tagx.xml> file or by adding a
C<.xml> file like C<s3.xml> that contains an C<s3> object.

 <object>
   <object name="s3">
     <scalar name="host">s3.amazonaws.com</scalar>
     <scalar name="secure">yes</scalar>
     <scalar name="aws_access_key_id">...</scalar>
     <scalar name="aws_secret_access_key">...</scalar>
   </object>
 </object>

Options are described below (environment variable, configuration variable).

=over 5

=item S3_HOST, host

default: s3.amazonaws.com

If you provide the name of a host other than C<s3.amazonaws.com>, then
DNS bucket names will be turned off unless you explicitly set that
variable. This is typically done when you are using a mocking service like
LocalStack and have not setup domain names for your buckets.

=item AWS_BUCKET, bucket (required)

The bucket name where session files will be stored.

=item session_prefix

The prefix to use when storing session files. Session files will be
stored in the bucket with at least the session id as the prefix. If
you want to store you session files with an additional prefix, set
this value in the configuration object.

=item AWS_ACCESS_KEY_ID, aws_access_key_id

You IAM user's access key.

I<NOTE: Best practice is to use environment variables or set a role
for you EC2 or container. Setting these variables in the environment
or the configuration file is optional. If you are running on an EC2
instance or an ECS container credentials can be retrieved
automatically from the instance metadata.

=item AWS_SECRET_ACCESS_KEY, aws_secret_access_key

You IAM user's secret access key.

=item AWS_SESSION_TOKEN

A temporary access token used when you assume a role.

=back

=head3 Methods

=over 5

=item get_s3

Returns an L<Amazon::S3> object.

=item get_bucket_name

Returns the bucket name.

=item get_bucket

Returns a L<Amazon::S3::Bucket> object.

=back

=head2 get_key_from_filename

 get_key_from_filename(filename, [session-dir]);

This poorly names method returns a path to an S3 object, possibly
replacing the 'session' with 'session-dir'. The premise here is that a
request was made for F<session/foo.pdf>. The object was stored under
the user's session directory. That is, 'session' is a virtual
directory that resolves at request time to be the user's session directory.

=head2 get_s3_session_file 

 get_s3_session_file(filename, session-dir)

Retrieves an object from S3 and returns it as a scalar.

=head2 send_s3_file

 send_s3_file(request-handler, filename, session-dir)

Retrieves a file from the S3 bucket that belongs to a particular
session. Attempts to determine the mime type by looking up the
extension in an internal table or by using L<File::Type>.

=head2 send_file 

 send_file(request-handler, filename)

Sends a file to the HTTP client. Attempts to determine the mime type
of the file using L<File::Type>.

I<TBD: Use Apache directly to send files on the local file system.>

=head1 SEE OTHER

L<Bedrock::S3>, L<Bedrock::Handler>, L<Bedrock::Apache::Request_cgi>, L<BLM::Startup::S3>

=head1 AUTHOR

Rob Lauer - <rlauer6@comcast.net>

=cut
